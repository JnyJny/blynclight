# Linux BlyncLight SDK
#
# Embrava ships a static library with their SDK which cannot be used
# directly by Python ctypes. However, we can pull the object files out
# of the library archive and relink them as a shared object.

# Fill out the form at:
#
# https://www.embrava.com/pages/embrava-software-sdk
#
# They will mail you links for Windows, Linux and Mac SDKs.  When you
# receive the Linux SDK URL, invoke make:
#
# $ make -f Makefile.Linux URL=https://url/for/the/sdk
#
# This makefile takes apart the static library archive and constructs
# a shared library which can then be used by python.
#

URL= "SDK URL HERE"

SDK_PATH=    EmbravaSdkForLinux

TARGET=  libblynclightcontrol.so
APIDIR=  EmbravaApi
BLC=     blynclightcontrol
BLC_OBJ= $(BLC).o
BLC_LIB= lib$(BLC)
BLC_AR=  $(BLC_LIB).a
BLC_SO=  $(TARGET)

HDRS= constants.h blynclightcontrol.h hdiapi.h

AR= ar
CC= cc
CP= cp
CURL= curl
MV= mv
RM= rm -rf
TAR= tar

shared_obj: $(SDK_PATH) $(BLC_SO)

## XXX The SDK is delivered as a zip file but unzip
##     doesn't unpack archives from stdout.  Luckily
##     macOS tar knows how to unpack zips.

$(SDK_PATH):
	@$(CURL) -L $(URL) | $(TAR) xf -

headers: $(HDRS)

%.h: $(SDK_PATH)
	@$(CP) $(SDK_PATH)/$(APIDIR)/$@ .

$(BLC_OBJ): $(SDK_PATH)
	@$(AR) -x $(SDK_PATH)/$(APIDIR)/$(BLC_AR) $(BLC_OBJ)

## XXX these cc flags for creating a shared library need
##     double checking for gcc
##
$(BLC_SO): $(BLC_OBJ)
	$(CC) -o $@ $(BLC_OBJ) -fpic -shared

clean:
	-@$(RM) $(BLC_AR) $(BLC_OBJ) __MACOSX

clobber: clean
	-@$(RM) $(BLC_SO) $(HDRS) $(SDK_PATH)


